import org.antlr.v4.runtime.tree.ParseTreeVisitor;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.CharStreams;
import java.io.IOException;

public class main {
    public static void main(String[] args) throws IOException{

	// we expect exactly one argument: the name of the input file
	if (args.length!=1) {
	    System.err.println("Please give as input argument a filename\n");
	    System.exit(-1);
	}
	String filename=args[0];

	// open the input file
	CharStream input = CharStreams.fromFileName(filename);
	    //new ANTLRFileStream (filename); // depricated

	// create a lexer/scanner
	implLexer lex = new implLexer(input);

	// get the stream of tokens from the scanner
	CommonTokenStream tokens = new CommonTokenStream(lex);

	// create a parser
	implParser parser = new implParser(tokens);

	// and parse anything from the grammar for "start"
	ParseTree parseTree = parser.start();

	// Construct the abstract syntax tree for the main block
	ASTMaker astMaker = new ASTMaker();
	Command mainblock=(Command)astMaker.visit(parseTree);

	// run the main block with a fresh environment
	//mainblock.eval(new Environment());
	//TODO:
	//Symtab env= new Symtab();


	// compile the main block with a fresh symbol table
	String compiled=mainblock.compile(new Symtab());
	System.out.println("Compiler result:\n\n"+compiled);
    }
}

// We write an interpreter that implements interface
// "implVisitor<T>" that is automatically generated by ANTLR
// This is parameterized over a return type "<T>" which is in our case
// simply a Double.

class Interpreter extends AbstractParseTreeVisitor<Double> implements implVisitor<Double> {

    static Environment env=new Environment();
    static String varname="";

    public Double visitStart(implParser.StartContext ctx){
	for(implParser.CommandContext c:ctx.cs) visit(c);
	return null;
    };

    public Double visitSingleCommand(implParser.SingleCommandContext ctx){
	return visit(ctx.c);
    }

    public Double visitMultipleCommands(implParser.MultipleCommandsContext ctx){
	for(implParser.CommandContext c:ctx.cs) visit(c);
	return null;
    }

    public Double visitAssignment(implParser.AssignmentContext ctx){
 	Double v=visit(ctx.e);
	visit(ctx.l);
	env.setVariable(varname,v);
	return null;
    }

    public Double visitForLoop(implParser.ForLoopContext ctx){
	String x=ctx.x.getText();
	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	env.setVariable(x,v1);
	while(!env.getVariable(x).equals(v2)){
	    visit(ctx.p);
	    env.setVariable(x,env.getVariable(x)+1);
	}
	return null;
    }
    public Double visitIf(implParser.IfContext ctx){
	if (visit(ctx.c).equals(1.0)) visit(ctx.p);
	return null;
    }
    public Double visitArray(implParser.ArrayContext ctx){
	Double v=visit(ctx.e);
	varname=ctx.a.getText()+"["+v+"]";
	return null;
    }
    public Double visitLefthandside(implParser.LefthandsideContext ctx){
	visit(ctx.l);
	return env.getVariable(varname);
    }
    public Double visitDisjunction(implParser.DisjunctionContext ctx){
	if(visit(ctx.c1).equals(1.0) || visit(ctx.c2).equals(1.0))
	    return 1.0;
	return 0.0;
    }
    public Double visitParenthesisCondition(implParser.ParenthesisConditionContext ctx){
	return visit(ctx.c);
    }
    public Double visitNegation(implParser.NegationContext ctx){
	if (visit(ctx.c).equals(1.0)) return 0.0;
	return 1.0;
    }

    public Double visitEqual(implParser.EqualContext ctx){
 	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.equals(v2))  return 1.0;
	else return 0.0;
    }
    public Double visitSmaller(implParser.SmallerContext ctx){Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.doubleValue()<v2.doubleValue())  return 1.0;
	else return 0.0;
    }
    public Double visitConjunction(implParser.ConjunctionContext ctx){
	if(visit(ctx.c1).equals(1.0) && visit(ctx.c2).equals(1.0))
	    return 1.0;
	return 0.0;
    }

    public Double visitOutput(implParser.OutputContext ctx){
	Double v=visit(ctx.e);
	System.out.println(v);
	return null;
    }

    public Double visitWhileLoop(implParser.WhileLoopContext ctx){
	while(visit(ctx.c).equals(1.0)){
	    visit(ctx.p);
	}
	return null;
    }

    public Double visitParenthesis(implParser.ParenthesisContext ctx){
	return visit(ctx.e);
    };

    public Double visitVariable(implParser.VariableContext ctx){
	varname=ctx.x.getText();
	return null;
    };

    public Double visitAddition(implParser.AdditionContext ctx){
	if (ctx.o.getText().equals("+"))
	    return visit(ctx.e1)+visit(ctx.e2);
	return visit(ctx.e1)-visit(ctx.e2);
    };

    public Double visitMultiplication(implParser.MultiplicationContext ctx){
	if (ctx.o.getText().equals("*"))
	    return visit(ctx.e1)*visit(ctx.e2);
	return visit(ctx.e1)/visit(ctx.e2);
    };

    public Double visitConstant(implParser.ConstantContext ctx){
	return Double.parseDouble(ctx.c.getText());
    };

    public Double visitUnequal(implParser.UnequalContext ctx){
	Double v1=visit(ctx.e1);
	Double v2=visit(ctx.e2);
	if (v1.equals(v2))  return 0.0;
	else return 1.0;
    }
}

class ASTMaker extends AbstractParseTreeVisitor<AST> implements implVisitor<AST> {

    static Environment env=new Environment();

    public AST visitStart(implParser.StartContext ctx){
	Command result=new Nop();
	for(implParser.CommandContext c:ctx.cs)
	    result=new Sequence(result,(Command)visit(c));
	return result;
    };

    public AST visitSingleCommand(implParser.SingleCommandContext ctx){
	return visit(ctx.c);
    }

    public AST visitMultipleCommands(implParser.MultipleCommandsContext ctx){
	Command result=new Nop();
	for(implParser.CommandContext c:ctx.cs) result=new Sequence(result,(Command)visit(c));
	return result;
    }

    //TODO: ADD ARRAY ASSIGNMENT
    public AST visitAssignment(implParser.AssignmentContext ctx){
	AST lhs=visit(ctx.l);
	if(lhs instanceof Variable){
	    Variable x = (Variable) lhs;
	    return new Assignment(x.name,(Expr)visit(ctx.e));
	}
	else faux.error("Arrays not yet implemented.\n");
	return null;
    }

    public AST visitOutput(implParser.OutputContext ctx){
	return new Output((Expr)visit(ctx.e));
    }

    public AST visitWhileLoop(implParser.WhileLoopContext ctx){
	return new While((Condition)visit(ctx.c),(Command)visit(ctx.p));
    }

    public AST visitParenthesis(implParser.ParenthesisContext ctx){
	return visit(ctx.e);
    };

    public AST visitVariable(implParser.VariableContext ctx){
	return new Variable(ctx.x.getText());
    };

    public AST visitAddition(implParser.AdditionContext ctx){
	if (ctx.o.getText().equals("+"))
	    return new Addition((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
	else
	    return new Subtraction((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    };

    public AST visitMultiplication(implParser.MultiplicationContext ctx){
	if (ctx.o.getText().equals("*"))
	    return new Multiplication((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
	else
	    return new Division((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    };

    public AST visitConstant(implParser.ConstantContext ctx){
	return new Constant(Double.parseDouble(ctx.c.getText()));
    };

    public AST visitUnequal(implParser.UnequalContext ctx){
	return new Unequal((Expr)visit(ctx.e1),(Expr)visit(ctx.e2));
    }


    //TODO: Not yet implemented:

    public AST visitSmaller(implParser.SmallerContext ctx){
	return null;
    }
    public AST visitConjunction(implParser.ConjunctionContext ctx){ return null;}
    public AST visitEqual(implParser.EqualContext ctx){return null;}
    public AST visitNegation(implParser.NegationContext ctx){return null;}

    public AST visitParenthesisCondition(implParser.ParenthesisConditionContext ctx){
	return visit(ctx.c); // we can forget about parentheses here
    }
    public AST visitDisjunction(implParser.DisjunctionContext ctx){return null;}
    public AST visitLefthandside(implParser.LefthandsideContext ctx){
	return visit(ctx.l);
    }
    public AST visitArray(implParser.ArrayContext ctx){return null;}
    public AST visitIf(implParser.IfContext ctx){return null;}
    public AST visitForLoop(implParser.ForLoopContext ctx){return null;}
}
